<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Opakovac√≠ hra s kartiƒçkami</title>
    <!-- Favicon using an emoji -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üí°</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Zmƒõnƒõno z 'center' na 'flex-start' pro zarovn√°n√≠ nahoru */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .game-container {
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 30px;
            width: 100%;
            max-width: 900px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 50px; /* P≈ôid√°no pro posunut√≠ od horn√≠ho okraje */
        }
        /* New wrapper for row bonus indicators and card grid */
        .grid-layout-wrapper {
            display: flex;
            /* No direct gap here, spacing will be managed by absolute positioning and grid-container margin */
            align-items: flex-start; /* Align items to the top of the flex container */
            justify-content: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            padding-top: 20px; /* Consistent top padding for the whole section */
            position: relative; /* Crucial for absolute positioning of row-bonus-indicators */
            width: 100%; /* Ensure it takes full width to position child absolutely */
        }
        .row-bonus-indicators {
            display: flex;
            flex-direction: column;
            justify-content: space-around; /* Distribute items evenly along the column */
            font-weight: bold;
            color: #4a5568;
            text-align: center;
            width: 30px; /* Narrow width for the container */
            box-sizing: border-box;
            flex-shrink: 0;
            border-right: 2px solid #cbd5e0; /* Still a right border */
            padding-right: 5px; /* Smaller padding */
            align-self: stretch; /* Make this element stretch to the height of its sibling (grid-container) */
            position: absolute; /* Absolute positioning */
            left: 0; /* Align to the far left of the wrapper */
            top: 20px; /* Match the top padding of the wrapper */
            bottom: 0; /* Extend to the bottom of the wrapper */
            transform-origin: center center; /* For potential future transformations */
        }
        .row-bonus-indicator-item {
            font-size: 0.9rem;
            color: #2d3748;
            display: flex; /* Keep it as flex for its own content */
            align-items: center; /* Vertically center content */
            justify-content: center; /* Horizontally center content */
            flex-grow: 1; /* Make it take equal available space */
            position: relative; /* For absolute positioning of its inner span */
            height: 100%; /* Ensure it fills its flex-grown space */
        }

        .row-bonus-indicator-item span { /* The actual text inside */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-90deg); /* Rotate text from bottom to top */
            transform-origin: center center;
            white-space: nowrap; /* Prevent text wrapping */
            padding: 0; /* No extra padding */
            margin: 0; /* No extra margin */
            display: flex; /* To align "Bonus:" and coins horizontally */
            align-items: center; /* Vertically align bonus content */
            justify-content: center; /* Center content horizontally */
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            flex-grow: 1;
            margin-top: 0; /* Ensure no conflicting top margin */
            margin-left: 50px; /* Add margin to make space for the vertical indicators */
            /* This margin needs to be wide enough to accommodate the rotated text */
        }
        .card {
            background-color: #e2e8f0; /* Default background */
            border-radius: 10px;
            padding: 15px;
            aspect-ratio: 1 / 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s;
            position: relative;
            font-weight: bold;
            color: #2d3748;
            font-size: 1rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
            text-align: center;
        }
        .card:hover:not(.selected):not(.answered) { /* Only hover if not selected/answered */
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.15);
        }
        .card.selected {
            border: 4px solid #4299e1;
            cursor: not-allowed; /* Change cursor when selected */
        }
        .card.answered {
            background-color: #cbd5e0 !important; /* Override color when answered */
            cursor: not-allowed;
            opacity: 0.7;
        }
        /* Difficulty specific colors */
        .card.difficulty-1-color { background-color: #d1fae5; } /* Tailwind green-200 */
        .card.difficulty-2-color { background-color: #fefcbf; } /* Tailwind yellow-200 */
        .card.difficulty-3-color { background-color: #fee2e2; } /* Tailwind red-200 */

        .difficulty-indicator {
            position: absolute;
            bottom: 5px; /* Change to bottom */
            right: 5px;
            font-size: 0.75rem;
            color: #4a5568;
            font-weight: normal;
            display: flex; /* Ensure content is flex to align Bonus: and coins */
            align-items: center;
            gap: 2px; /* Small gap between "Bonus:" and coins */
        }
        .question-area {
            background-color: #edf2f7;
            border-radius: 10px;
            padding: 25px;
            margin-top: 20px;
            text-align: left;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        .question-text {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 20px;
        }
        .options-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }
        .option-button {
            background-color: #63b3ed;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: left;
        }
        .option-button:hover {
            background-color: #4299e1;
            transform: translateY(-2px);
        }
        .option-button.correct {
            background-color: #48bb78;
        }
        .option-button.incorrect {
            background-color: #f56565;
        }
        .feedback-message {
            margin-top: 20px;
            font-size: 1.2rem;
            font-weight: bold;
        }
        .start-button, .restart-button {
            background-color: #4c51bf;
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.3rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            margin-top: 20px;
            width: fit-content;
            align-self: center;
        }
        .start-button:hover, .restart-button:hover {
            background-color: #3f44a9;
            transform: translateY(-2px);
        }
        .score-display {
            font-size: 1.8rem;
            font-weight: bold;
            color: #2c5282;
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping for multiple player scores */
        }
        .player-score-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 15px;
            border-radius: 8px;
            background-color: #edf2f7;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            margin: 5px;
            min-width: 120px;
            text-align: center;
        }
        .player-score-card.current-player {
            background-color: #d1e7ff; /* Light blue background for current player */
            border: 2px solid #007bff; /* Blue border for current player */
            transform: translateY(-3px); /* Slightly lift current player card */
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .player-score-name {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 5px;
            color: #2c5282; /* Default name color */
        }
        .player-score-emoji {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }
        .player-score-points {
            font-weight: bold;
            font-size: 1.3rem;
            color: #2c5282; /* Default score color */
        }
        
        .remaining-cards-display {
            font-size: 1.2rem;
            color: #4a5568;
            width: 100%; /* Take full width to center below scores */
            margin-top: 10px; /* Add some space from score cards */
        }

        /* Modal styling */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            /* Added max-height for scrollability in results modal */
            max-height: 90vh; /* Limit height to 90% of viewport height */
            overflow-y: auto; /* Enable vertical scrolling */
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;
        }
        .modal-overlay.visible .modal-content {
            transform: translateY(0);
        }
        .modal-content h3 {
            font-size: 1.8rem;
            margin-bottom: 15px;
            color: #2d3748;
        }
        .modal-content p {
            font-size: 1.0rem; /* Slightly smaller font for compactness */
            color: #4a5568;
            margin-bottom: 8px; /* Adjusted for multiple paragraphs */
            text-align: left;
        }
        .modal-content ul {
            text-align: left;
            margin-bottom: 15px;
            max-height: 200px; /* Limit height for scrollable content */
            overflow-y: auto; /* Enable scrolling */
            border: 1px solid #e2e8f0;
            padding: 10px;
            border-radius: 8px;
            background-color: #f7fafc;
        }
        .modal-content li {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px dashed #cbd5e0;
        }
        .modal-content li:last-child {
            border-bottom: none;
        }
        .modal-content .question-text-small {
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 5px;
        }
        .modal-content .answer-text-small {
            font-size: 0.95rem;
            color: #48bb78; /* Correct answer in green */
        }
        .modal-content .user-answer-text-small {
            font-size: 0.95rem;
            color: #f56565; /* User's incorrect answer in red */
        }
        .modal-buttons-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        .modal-button {
            background-color: #4c51bf;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .modal-button:hover {
            background-color: #3f44a9;
        }
        .modal-button.secondary {
            background-color: #6c757d;
        }
        .modal-button.secondary:hover {
            background-color: #5a6268;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .grid-layout-wrapper {
                flex-direction: column; /* Stack row indicators and grid */
                align-items: center;
                padding-top: 10px; /* Adjust top padding for smaller screens */
            }
            .row-bonus-indicators {
                position: static; /* Remove absolute positioning on mobile */
                width: 100%;
                flex-direction: row; /* Make row indicators horizontal */
                justify-content: center;
                border-right: none;
                border-bottom: 2px solid #cbd5e0; /* Add bottom border */
                padding-right: 0;
                padding-bottom: 10px;
                align-self: auto; /* Reset align-self */
                min-height: auto;
                height: auto; /* Allow height to be determined by content */
            }
            .row-bonus-indicator-item {
                border-right: none; /* Remove right border */
                justify-content: center;
                padding: 5px;
                min-height: auto;
                flex-grow: 0; /* No grow on mobile horizontal */
            }
            .row-bonus-indicator-item span {
                position: static; /* Remove absolute positioning on mobile */
                transform: none; /* Remove rotation on mobile */
                white-space: normal; /* Allow wrapping on mobile */
            }
            .grid-container {
                margin-top: 10px; /* Reduce top margin */
                margin-left: 0; /* Remove left margin on mobile */
            }
            .card {
                font-size: 0.9rem; /* Smaller font on small screens */
                padding: 10px;
            }
            .score-display {
                flex-direction: column;
                gap: 10px;
            }
            .player-score-card {
                min-width: 100px;
                padding: 8px 12px;
            }
            .modal-content {
                max-height: 80vh; /* Adjust modal max-height for very small screens */
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Removed h1 title as per request -->
        <!-- Added a div for the title to remove the "Opakovaƒçky" text -->
        <div class="text-4xl font-extrabold text-blue-800 mb-6"></div> 
        <div id="all-players-score-display" class="score-display">
            <!-- All player score cards will be rendered here by JS -->
            <span class="remaining-cards-display hidden" id="remaining-cards-display">Zb√Ωv√°: -- kartiƒçek</span>
        </div>
        
        <!-- The individual player turn indicator below the main score area -->
        <!-- This is now integrated into the all-players-score-display by highlighting -->


        <!-- Game Setup Screen -->
        <div id="game-setup-screen" class="flex flex-col items-center">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Nastaven√≠ hry</h2>
            
            <div class="mb-4">
                <label for="num-players" class="block text-gray-700 text-sm font-bold mb-2">Poƒçet hr√°ƒç≈Ø: <span id="num-players-value">1</span></label>
                <input type="range" id="num-players" value="1" min="1" max="5" 
                       class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
            </div>

            <div class="mb-6">
                <label for="total-cards-input" class="block text-gray-700 text-sm font-bold mb-2">Celkem ot√°zek: <span id="total-cards-value">15</span></label>
                <input type="range" id="total-cards-input" value="15" min="1"
                       class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
            </div>

            <div class="mb-6">
                <label for="flashcard-set-select" class="block text-gray-700 text-sm font-bold mb-2">Vybrat sadu kartiƒçek:</label>
                <select id="flashcard-set-select" class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <!-- Options will be populated by JS -->
                </select>
            </div>


            <p class="text-md text-gray-600 mb-8" id="game-instructions">Z√°kladn√≠ bodov√°n√≠: +1 za spr√°vnou, -1 za ≈°patnou. Bonusy za ≈ô√°dek a obt√≠≈ænost se p≈ôiƒç√≠taj√≠/odeƒç√≠taj√≠ k tomu.</p>
            <button id="setup-game-button" class="start-button">Zaƒç√≠t hru</button>
        </div>


        <div id="game-play-area" class="hidden">
            <div class="grid-layout-wrapper">
                <div class="row-bonus-indicators">
                    <div class="row-bonus-indicator-item">
                        <span>Bonus: 
                            <!-- No coin for 0 points (Difficulty 1) -->
                        </span>
                    </div>
                    <div class="row-bonus-indicator-item">
                        <span>Bonus: 
                            <svg xmlns="http://www.w3.org/2000/svg" class="inline-block w-4 h-4 ml-1" viewBox="0 0 24 24" fill="#FFD700" stroke="#B8860B" stroke-width="1.5">
                                <circle cx="12" cy="12" r="10"/>
                                <text x="12" y="15" font-family="Verdana" font-size="10" fill="#FFFFFF" text-anchor="middle" font-weight="bold">‚òÖ</text>
                            </svg>
                        </span>
                    </div>
                    <div class="row-bonus-indicator-item">
                        <span>Bonus: 
                            <svg xmlns="http://www.w3.org/2000/svg" class="inline-block w-4 h-4 ml-1" viewBox="0 0 24 24" fill="#FFD700" stroke="#B8860B" stroke-width="1.5">
                                <circle cx="12" cy="12" r="10"/>
                                <text x="12" y="15" font-family="Verdana" font-size="10" fill="#FFFFFF" text-anchor="middle" font-weight="bold">‚òÖ</text>
                            </svg>
                            <svg xmlns="http://www.w3.org/2000/svg" class="inline-block w-4 h-4 ml-1" viewBox="0 0 24 24" fill="#FFD700" stroke="#B8860B" stroke-width="1.5">
                                <circle cx="12" cy="12" r="10"/>
                                <text x="12" y="15" font-family="Verdana" font-size="10" fill="#FFFFFF" text-anchor="middle" font-weight="bold">‚òÖ</text>
                            </svg>
                        </span>
                    </div>
                </div>
                <div class="grid-container" id="card-grid">
                    <!-- Cards will be generated here by JS -->
                </div>
            </div>

            <div id="question-area" class="question-area hidden">
                <div id="question-text" class="question-text"></div>
                <div class="options-grid" id="options-container">
                    <!-- Answer options will be generated here by JS -->
                </div>
                <div id="feedback-message" class="feedback-message hidden"></div>
            </div>
            <!-- These buttons are now managed by modals -->
            <button id="next-round-button" class="start-button hidden">Dal≈°√≠ kolo</button>
            <button id="restart-game-button" class="restart-button hidden">Restartovat hru</button>
        </div>
    </div>

    <!-- Custom Modal for Messages -->
    <div id="message-modal-overlay" class="modal-overlay">
        <div class="modal-content">
            <h3 id="modal-title"></h3>
            <div id="modal-content-body"></div> <!-- Dynamic content goes here -->
            <div class="modal-buttons-container" id="modal-buttons-container">
                <button id="modal-primary-button" class="modal-button"></button>
                <button id="modal-secondary-button" class="modal-button secondary hidden"></button>
            </div>
        </div>
    </div>

    <script>
        // Otev≈ôe modal pro √∫pravu jm√©na a ikony dan√©ho hr√°ƒçe
        function openEditPlayerModal(index) {
            const player = players[index];
        
            // Vezmeme tvoji existuj√≠c√≠ sadu, p≈ô√≠padnƒõ dopln√≠me o p√°r obecn√Ωch
            const baseChoices = (typeof PLAYER_EMOJIS !== 'undefined' && Array.isArray(PLAYER_EMOJIS) && PLAYER_EMOJIS.length)
                ? PLAYER_EMOJIS
                : ['üöÄ','üåü','üí°','üå±','ü§ñ','üéâ','üß†','‚ú®','üèÜ','üéØ'];
        
            // Unik√°tn√≠ seznam + p√°r ‚Äûklasik‚Äú nav√≠c (duplicit se zbav√≠me pomoc√≠ Set)
            const emojiChoices = Array.from(new Set([
                ...baseChoices,
                'üê±','üê∂','ü¶ä','üêº','ü¶Å','üê∏','üêß','üê®','üêØ','üêµ',
                '‚öΩ','üèÄ','üèà','üé∏','üéß','üé≤','üìö','üß™','üó∫Ô∏è','üß≠'
            ])).slice(0, 24); // rozumn√Ω strop, a≈• se modal nep≈ôepln√≠
        
            const contentHTML = `
                <div class="text-left">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Jm√©no hr√°ƒçe</label>
                    <input id="edit-player-name" type="text" value="${player.name}"
                           class="w-full p-2 border border-gray-300 rounded mb-4" />
        
                    <label class="block text-sm font-medium text-gray-700 mb-2">Vyberte ikonu</label>
                    <div id="emoji-picker" class="grid grid-cols-6 gap-2">
                        ${emojiChoices.map(e => `
                            <button type="button"
                                class="border rounded px-2 py-1 text-xl hover:bg-gray-100 transition
                                       ${e === player.emoji ? 'ring-2 ring-blue-500' : ''}"
                                data-emoji="${e}"
                                aria-label="Zvolit ${e}">
                                ${e}
                            </button>
                        `).join('')}
                    </div>
        
                    <p class="text-xs text-gray-500 mt-3">
                        Kliknut√≠m vyberte ikonu. Jm√©no m≈Ø≈æete napsat libovolnƒõ.
                    </p>
                </div>
            `;
        
            showGameModal(
                "Upravit hr√°ƒçe",
                contentHTML,
                "Ulo≈æit",
                () => {
                    const nameInput = document.getElementById('edit-player-name');
                    const chosen = document.querySelector('#emoji-picker button.ring-2');
                    const newName = (nameInput?.value ?? "").trim();
                    const newEmoji = chosen?.dataset.emoji;
        
                    if (newName.length > 0) {
                        player.name = newName;
                    }
                    if (newEmoji) {
                        player.emoji = newEmoji;
                    }
        
                    window.updateScoreDisplay();
                },
                "Zru≈°it",
                () => {}
            );
        
            // Napoj√≠me v√Ωbƒõr emoji (vyhraje v≈ædy posledn√≠ klik)
            const picker = document.getElementById('emoji-picker');
            if (picker) {
                picker.addEventListener('click', (e) => {
                    const btn = e.target.closest('button[data-emoji]');
                    if (!btn) return;
                    // zru≈°it p≈ôedchoz√≠ v√Ωbƒõr
                    picker.querySelectorAll('button.ring-2').forEach(b => b.classList.remove('ring-2','ring-blue-500'));
                    // oznaƒçit aktu√°ln√≠
                    btn.classList.add('ring-2','ring-blue-500');
                });
            }
        }

        // Function to generate coin SVG
        function getCoinSvgIcon() {
            return `<svg xmlns="http://www.w3.org/2000/svg" class="inline-block w-4 h-4 ml-1" viewBox="0 0 24 24" fill="#FFD700" stroke="#B8860B" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10"/>
                        <text x="12" y="15" font-family="Verdana" font-size="10" fill="#FFFFFF" text-anchor="middle" font-weight="bold">‚òÖ</text>
                    </svg>`;
        }

        // Data for flashcards (question, correct answer, incorrect options, difficulty)
        // This will now be populated from Google Sheets
        let flashcardsData = []; 
        
        let numPlayers = 1;
        let TOTAL_CARDS_TO_ANSWER = 15; // This will be dynamic based on setup
        const DEFAULT_CARDS_PER_PLAYER = {
            1: 15,
            2: 20,
            3: 27,
            4: 32,
            5: 35
        };

        const FLASHCARD_SETS = {
            "1.rocnik_rany_vrcholny_stredovek": {
                name: "St≈ôedovƒõk a≈æ po reformaci", // Updated name
                url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vQcFX-XElafI31HsHhWZ_e8xdCJREnUMvVkv3u0YG31yd7VAwhX2o8WnxKXrjZBkLhR3rreQaJtqVHO/pub?gid=1607867200&single=true&output=tsv"
            },
            "2.rocnik_rany_novovek_19_stoleti": {
                name: "Ran√Ω novovƒõk a≈æ po pr≈Ømyslovou revoluci", // Updated name
                url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vTZkADdaKWqFzTm6EVGquT6ZIxKOFpPC4dmHzBMgaMP2-TZCE99Hhh2sX3aoGR7ohx3BF8VNGY8IrU6/pub?gid=997575850&single=true&output=tsv" // Corrected GID and output format
            },
            "3.rocnik_moderni_dejiny": {
                name: "V≈°ehochu≈•",
                url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vTldhmt4IR1qDuF8WOJXsu0yDPRDV41RpLs4cLY3sVZUH9dXwJsiXL_rjyaJBakg2yn4NEh6f8vG5vB/pub?output=tsv"
            }
        };

        let currentFlashcardSetUrl = FLASHCARD_SETS["1.rocnik_rany_vrcholny_stredovek"].url; // Default set

        let players = []; // Array of player objects
        let currentPlayerIndex = 0; // Index of the current player
        let answeredCardsTotal = 0; // Total cards answered across all players in this game

        let availableCards = []; // The 9 cards currently in the grid
        let currentQuestion = null; // The currently selected card object from availableCards
        let isQuestionActive = false; // Flag to disable card selection when a question is active
        
        // Define player colors, names, and emojis
        const PLAYER_COLORS = ['#34D399', '#60A5FA', '#A78BFA', '#FBBF24', '#FB7185']; // Tailwind colors: emerald-400, blue-400, violet-400, amber-400, rose-400
        const PLAYER_NAMES = ['Adam', 'Petra', 'Max', 'Ema', 'Karel', 'Julie', 'Tom√°≈°', 'Anna', 'Luk√°≈°', 'Tereza']; // More gender-neutral names
        const PLAYER_EMOJIS = ['üöÄ', 'üåü', 'üí°', 'üå±', 'ü§ñ', 'üéâ', 'üß†', '‚ú®', 'üèÜ', 'üéØ'];

        // DOM elements - Declared globally, assigned in updateDomElementReferences
        let allPlayersScoreDisplay;
        let remainingCardsDisplay;
        let cardGrid;
        let questionArea; 
        let feedbackMessage; 

        let setupGameButton;
        let gameSetupScreen;
        let gamePlayArea;
        let numPlayersInput;
        let totalCardsInput;
        let totalCardsValueSpan;
        let numPlayersValueSpan;
        let flashcardSetSelect;

        // Modal elements
        const messageModalOverlay = document.getElementById('message-modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalContentBody = document.getElementById('modal-content-body');
        const modalPrimaryButton = document.getElementById('modal-primary-button');
        const modalSecondaryButton = document.getElementById('modal-secondary-button');


        // --- TOOLTIP RELATED CODE START ---
        const tooltipElement = document.createElement('div');
        tooltipElement.id = 'card-tooltip';
        // Tailwind classes for styling, plus custom styles for positioning and visibility
        tooltipElement.classList.add('hidden', 'fixed', 'bg-gray-800', 'text-white', 'p-2', 'rounded-md', 'shadow-lg', 'text-sm', 'z-50', 'transition-opacity', 'duration-150'); /* Removed pointer-events-none */
        tooltipElement.style.maxWidth = '300px'; // Limit tooltip width
        tooltipElement.style.wordWrap = 'break-word'; // Allow long words to break
        tooltipElement.style.opacity = '0'; // Start hidden for transition
        document.body.appendChild(tooltipElement);

        let tooltipHideTimeout; // Variable to hold the timeout ID

        // Add mouseover and mouseout listeners to the tooltip itself
        tooltipElement.addEventListener('mouseover', () => {
            clearTimeout(tooltipHideTimeout); // Clear any pending hide
        });
        tooltipElement.addEventListener('mouseout', () => {
            hideTooltipWithDelay(); // Hide with delay when leaving the tooltip
        });


        function showTooltip(text, x, y) {
            clearTimeout(tooltipHideTimeout); // Clear any pending hide on show
            tooltipElement.textContent = text;
            tooltipElement.classList.remove('hidden');
            // Force reflow to ensure transition starts from opacity 0
            // This is a common trick to make CSS transitions work when changing display/visibility
            tooltipElement.offsetWidth; 
            tooltipElement.style.opacity = '1';
            positionTooltip(x, y);
        }

        function hideTooltip() {
            tooltipElement.style.opacity = '0';
            // Use a small delay before hiding completely to allow transition to finish
            setTimeout(() => {
                tooltipElement.classList.add('hidden');
            }, 150); // Match transition duration
        }

        function hideTooltipWithDelay() {
            clearTimeout(tooltipHideTimeout); // Clear any existing timeout before setting a new one
            tooltipHideTimeout = setTimeout(() => {
                hideTooltip();
            }, 300); // Adjust delay as needed (e.g., 300ms)
        }

        function positionTooltip(mouseX, mouseY) {
            const padding = 15; // Distance from cursor
            let finalX = mouseX + padding;
            let finalY = mouseY + padding;

            // To get accurate width/height, temporarily make it visible but transparent/off-screen
            const originalOpacity = tooltipElement.style.opacity;
            const originalVisibility = tooltipElement.style.visibility;
            tooltipElement.style.opacity = '0';
            tooltipElement.style.visibility = 'visible';
            tooltipElement.classList.remove('hidden'); // Ensure it's not display:none for measurement

            const tooltipWidth = tooltipElement.offsetWidth;
            const tooltipHeight = tooltipElement.offsetHeight;

            // Restore original styles (or hide if it was hidden initially)
            tooltipElement.style.opacity = originalOpacity;
            tooltipElement.style.visibility = originalVisibility;
            if (originalOpacity === '0') {
                tooltipElement.classList.add('hidden');
            }


            // Adjust if it goes off the right edge of the viewport
            if (finalX + tooltipWidth > window.innerWidth - 10) { // Small buffer from right edge
                finalX = mouseX - tooltipWidth - padding; // Place to the left of the cursor
            }

            // Adjust if it goes off the bottom edge of the viewport
            if (finalY + tooltipHeight > window.innerHeight - 10) { // Small buffer from bottom edge
                finalY = mouseY - tooltipHeight - padding; // Place above the cursor
            }

            // Ensure it doesn't go off the left edge (can happen after right edge adjustment)
            if (finalX < 10) { // Small margin from left edge
                finalX = 10;
            }

            // Ensure it doesn't go off the top edge (can happen after bottom edge adjustment)
            if (finalY < 10) { // Small margin from top edge
                finalY = 10;
            }

            tooltipElement.style.left = `${finalX}px`;
            tooltipElement.style.top = `${finalY}px`;
        }

        function handleCardMouseOver(event) {
            const cardElement = event.currentTarget;
            const fullText = cardElement.dataset.fullQuestion;
            // Assuming truncation occurs if length > 50 (from `questionSnippet` logic)
            if (fullText && fullText.length > 50) { 
                showTooltip(fullText, event.clientX, event.clientY);
            }
        }

        function handleCardMouseMove(event) {
            // Only reposition if the tooltip is currently visible (not hidden by CSS class)
            if (!tooltipElement.classList.contains('hidden')) {
                positionTooltip(event.clientX, event.clientY);
            }
        }

        function handleCardMouseOut(event) {
            // Initiate hide with a delay
            hideTooltipWithDelay();
        }
        // --- TOOLTIP RELATED CODE END ---

        // Function to update all global DOM element references
        function updateDomElementReferences() {
            allPlayersScoreDisplay = document.getElementById('all-players-score-display');
            remainingCardsDisplay = document.getElementById('remaining-cards-display');
            cardGrid = document.getElementById('card-grid');
            questionArea = document.getElementById('question-area'); 
            feedbackMessage = document.getElementById('feedback-message'); 

            setupGameButton = document.getElementById('setup-game-button');
            gameSetupScreen = document.getElementById('game-setup-screen');
            gamePlayArea = document.getElementById('game-play-area');
            numPlayersInput = document.getElementById('num-players');
            totalCardsInput = document.getElementById('total-cards-input');
            totalCardsValueSpan = document.getElementById('total-cards-value');
            numPlayersValueSpan = document.getElementById('num-players-value');
            flashcardSetSelect = document.getElementById('flashcard-set-select');
        }


        /**
         * Updates the default total cards input (slider) based on the selected number of players.
         * Also sets the max attribute of the slider.
         */
        function updateDefaultTotalCards() {
            // Ensure elements exist before accessing them
            if (!numPlayersInput || !totalCardsInput || !totalCardsValueSpan || !numPlayersValueSpan || flashcardsData.length === 0) {
                console.warn("Required setup elements or flashcards data not ready for updateDefaultTotalCards.");
                return;
            }
            
            const selectedPlayers = parseInt(numPlayersInput.value);
            let defaultValue = DEFAULT_CARDS_PER_PLAYER[selectedPlayers] || DEFAULT_CARDS_PER_PLAYER[1];
            
            // Ensure the default value does not exceed the total available unique flashcards
            defaultValue = Math.min(defaultValue, flashcardsData.length);

            totalCardsInput.value = defaultValue;
            totalCardsInput.max = flashcardsData.length; // Set max attribute of the slider
            totalCardsValueSpan.textContent = defaultValue; // Update the span next to the slider
            numPlayersValueSpan.textContent = selectedPlayers; // Update the span for number of players
        }

        /**
         * Resets game parameters and state (players, scores, etc.) to initial values.
         * This is called when starting a new game or changing flashcard sets.
         * IMPORTANT: This function no longer resets currentFlashcardSetUrl or flashcardSetSelect.value.
         * Those are handled by the loadFlashcards() call directly after a set change.
         */
        function resetGameParametersAndState() {
            numPlayers = 1; 
            currentPlayerIndex = 0;
            answeredCardsTotal = 0;
            players = []; // Clear all player data
            usedFlashcardOriginalIndices.clear(); // Clear all used card indices
            availableCards = []; // Clear current grid cards

            // Reset UI elements - Use null checks for safety
            if (gamePlayArea) gamePlayArea.classList.add('hidden'); 
            if (questionArea) questionArea.classList.add('hidden'); 
            if (cardGrid) cardGrid.innerHTML = ''; 
            if (feedbackMessage) feedbackMessage.classList.add('hidden'); 
            if (remainingCardsDisplay) remainingCardsDisplay.classList.add('hidden'); 

            // Reset setup screen sliders and their displayed values
            const setupScreen = document.getElementById('game-setup-screen');
            if (setupScreen) {
                setupScreen.classList.remove('hidden'); // Show setup screen
                // Re-fetch references for elements within setup screen
                updateDomElementReferences(); // Ensure all setup-related elements are current
                
                if (numPlayersInput) numPlayersInput.value = '1';
                if (numPlayersValueSpan) numPlayersValueSpan.textContent = '1';
                
                // Set total cards based on default (1 player) after numPlayers is reset
                TOTAL_CARDS_TO_ANSWER = DEFAULT_CARDS_PER_PLAYER[1];
                if (totalCardsInput) totalCardsInput.value = TOTAL_CARDS_TO_ANSWER;
                if (totalCardsValueSpan) totalCardsValueSpan.textContent = TOTAL_CARDS_TO_ANSWER;

                // Do NOT touch flashcardSetSelect.value or currentFlashcardSetUrl here.
                // It's assumed the calling function (e.g., loadFlashcards or change listener)
                // has already set or will set the correct value.
            }
            window.updateScoreDisplay(); // Update scoreboard (will show empty/reset scores)
        }


        /**
         * Initializes the game based on user setup (number of players, total cards).
         */
        function setupGame() {
            // Get fresh references for setup elements before using them
            updateDomElementReferences(); // Ensure all elements are current

            numPlayers = parseInt(numPlayersInput.value);
            TOTAL_CARDS_TO_ANSWER = parseInt(totalCardsInput.value);
            currentFlashcardSetUrl = flashcardSetSelect.value; // Ensure current URL is based on selection


            // Ensure numPlayers is within bounds
            if (isNaN(numPlayers) || numPlayers < 1 || numPlayers > 5) {
                numPlayers = 1; 
                numPlayersInput.value = 1;
            }
            // Ensure TOTAL_CARDS_TO_ANSWER is within bounds (1 and max available unique cards)
            if (isNaN(TOTAL_CARDS_TO_ANSWER) || TOTAL_CARDS_TO_ANSWER < 1 || TOTAL_CARDS_TO_ANSWER > flashcardsData.length) {
                TOTAL_CARDS_TO_ANSWER = Math.min(DEFAULT_CARDS_PER_PLAYER[numPlayers], flashcardsData.length); 
                totalCardsInput.value = TOTAL_CARDS_TO_ANSWER;
            }

            // Initialize players with unique names, colors, and emojis
            players = [];
            const shuffledNames = shuffleArray([...PLAYER_NAMES]);
            const shuffledEmojis = shuffleArray([...PLAYER_EMOJIS]);
            const shuffledColors = shuffleArray([...PLAYER_COLORS]);

            for (let i = 0; i < numPlayers; i++) {
                players.push({
                    name: shuffledNames[i % shuffledNames.length], // Cycle through names if more players than names
                    score: 0,
                    correctAnswers: 0,
                    incorrectAnswers: 0,
                    incorrectAnswersHistory: [],
                    color: shuffledColors[i % shuffledColors.length], // Assign a color
                    emoji: shuffledEmojis[i % shuffledEmojis.length] // Assign an emoji
                });
            }

            currentPlayerIndex = 0;
            answeredCardsTotal = 0;
            // IMPORTANT: usedFlashcardOriginalIndices must be cleared at the START of a new game,
            // and should NOT be reset mid-game if we run out of unique cards,
            // to ensure no repeats *within one game session*.
            usedFlashcardOriginalIndices.clear(); 

            if (gameSetupScreen) gameSetupScreen.classList.add('hidden');
            if (gamePlayArea) gamePlayArea.classList.remove('hidden');

            initializeGameRound();
        }

        /**
         * Function to show a custom modal message
         * @param {string} title - The title of the modal.
         * @param {string} contentHTML - The HTML content for the modal body.
         * @param {string} [primaryBtnText=null] - Text for the primary button.
         * @param {function} [primaryBtnCallback=null] - Callback for the primary button.
         * @param {string} [secondaryBtnText=null] - Text for the secondary button.
         * @param {function} [secondaryBtnCallback=null] - Callback for the secondary button.
         */
        function showGameModal(title, contentHTML, primaryBtnText = null, primaryBtnCallback = null, secondaryBtnText = null, secondaryBtnCallback = null) {
            modalTitle.textContent = title;
            modalContentBody.innerHTML = contentHTML;

            modalPrimaryButton.onclick = null;
            modalSecondaryButton.onclick = null;
            if (modalPrimaryButton) modalPrimaryButton.classList.add('hidden');
            if (modalSecondaryButton) modalSecondaryButton.classList.add('hidden');

            if (primaryBtnText && primaryBtnCallback) {
                if (modalPrimaryButton) {
                    modalPrimaryButton.textContent = primaryBtnText;
                    modalPrimaryButton.onclick = () => {
                        if (messageModalOverlay) messageModalOverlay.classList.remove('visible');
                        primaryBtnCallback();
                    };
                    modalPrimaryButton.classList.remove('hidden');
                }
            }
            if (secondaryBtnText && secondaryBtnCallback) {
                if (modalSecondaryButton) {
                    modalSecondaryButton.textContent = secondaryBtnText;
                    modalSecondaryButton.onclick = () => {
                        if (messageModalOverlay) messageModalOverlay.classList.remove('visible');
                        secondaryBtnCallback();
                    };
                    modalSecondaryButton.classList.remove('hidden');
                }
            }
            if (messageModalOverlay) messageModalOverlay.classList.add('visible');
        }

        // Utility function to shuffle an array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array; // Return the shuffled array
        }

        // Global set to track original flashcard indices that have been used across all rounds in this session
        let usedFlashcardOriginalIndices = new Set();

        /**
         * Gets the next available flashcard data, ensuring no repeats within the current game.
         * Returns null if all unique cards have been used for this game.
         */
        function getNextAvailableFlashcardData() {
            const availableOriginalIndices = [];
            for (let i = 0; i < flashcardsData.length; i++) {
                if (!usedFlashcardOriginalIndices.has(i)) {
                    availableOriginalIndices.push(i);
                }
            }

            if (availableOriginalIndices.length === 0) {
                return null; // All unique cards have been used for this game session
            }

            const randomIndex = Math.floor(Math.random() * availableOriginalIndices.length);
            const originalIndex = availableOriginalIndices[randomIndex];

            usedFlashcardOriginalIndices.add(originalIndex); // Mark as used for this game
            return { originalIndex: originalIndex, data: flashcardsData[originalIndex] };
        }

        /**
         * Initializes a new round (or the first round) of the game.
         * This means populating and rendering a new grid.
         */
        function initializeGameRound() {
            isQuestionActive = false; // Allow new card selection
            // If it's the very first time populating or if all cards were answered, fill all 9 slots
            if (availableCards.length === 0 || availableCards.every(card => card.originalIndex === -1)) {
                populateInitialFullGrid(); // Populate the grid with 9 new cards
            }
            window.updateScoreDisplay(); // Update current player's score and total remaining cards
            if (remainingCardsDisplay) remainingCardsDisplay.classList.remove('hidden'); // Show remaining cards display when game starts
        }

        // Updates the score and remaining cards displayed on the screen.
        // Explicitly defining on window object to ensure global accessibility
        // ‚¨áÔ∏è NAHRAƒé t√≠mto cel√Ω p≈Øvodn√≠ blok window.updateScoreDisplay = function() { ... }
        window.updateScoreDisplay = function() { 
            // Vyƒçisti existuj√≠c√≠ karty (z≈Øst√°v√° jen "Zb√Ωv√°: ...", kter√Ω znovu p≈ôipoj√≠me n√≠≈æe)
            if (allPlayersScoreDisplay) allPlayersScoreDisplay.innerHTML = ''; 
        
            players.forEach((player, index) => {
                const playerScoreCard = document.createElement('div');
                playerScoreCard.classList.add('player-score-card');
                if (index === currentPlayerIndex) {
                    playerScoreCard.classList.add('current-player');
                }
        
                playerScoreCard.innerHTML = `
                    <span class="player-score-emoji">${player.emoji}</span>
                    <span class="player-score-name" style="color: ${player.color};">${player.name}</span>
                    <span class="player-score-points">${player.score} bod≈Ø</span>
                `;
        
                // ‚úÖ Nov√©: umo≈æn√≠ kliknut√≠m upravit jm√©no/ikonu (bez zmƒõny vzhledu ƒçi logiky)
                playerScoreCard.title = 'Kliknut√≠m uprav√≠te jm√©no a ikonu';
                playerScoreCard.addEventListener('click', () => openEditPlayerModal(index));
        
                if (allPlayersScoreDisplay) allPlayersScoreDisplay.appendChild(playerScoreCard);
            });
        
            // Znovu p≈ôipojit "Zb√Ωv√°: ..." ukazatel
            if (allPlayersScoreDisplay && remainingCardsDisplay) {
                allPlayersScoreDisplay.appendChild(remainingCardsDisplay);
            }
        
            const remaining = TOTAL_CARDS_TO_ANSWER - answeredCardsTotal;
            if (remainingCardsDisplay) {
                remainingCardsDisplay.textContent = `Zb√Ωv√°: ${Math.max(0, remaining)} kartiƒçek`;
                remainingCardsDisplay.classList.remove('hidden'); // Pro jistotu viditeln√© po startu hry
            }
        };


        /**
         * Populates the grid initially with 9 new unique cards.
         * This function is only called at the very start of a new game.
         */
        function populateInitialFullGrid() {
            availableCards = [];
            for (let i = 0; i < 9; i++) {
                const newCard = getNextAvailableFlashcardData();
                if (newCard && answeredCardsTotal < TOTAL_CARDS_TO_ANSWER) {
                    availableCards.push({
                        uniqueGridId: i, // Initially assigned sequential uniqueGridIds
                        originalIndex: newCard.originalIndex,
                        data: newCard.data,
                        answered: false
                    });
                } else {
                    // Fill with placeholder if no more cards or game limit reached
                    availableCards.push({
                        uniqueGridId: i,
                        originalIndex: -1, // Empty placeholder index
                        data: { question: "", answer: "", options: [], difficulty: 0 }, // Empty placeholder data
                        answered: true // Marked as answered so it's not clickable
                    });
                }
            }
            // IMPORTANT: Removed shuffleArray(availableCards) here to ensure initial sequential order
            // as per the new "shift" requirement.

            renderCardGrid();
            if (questionArea) questionArea.classList.add('hidden');
            if (feedbackMessage) feedbackMessage.classList.add('hidden');
        }


        // Renders the 3x3 card grid based on `availableCards`
        function renderCardGrid() {
            if (cardGrid) cardGrid.innerHTML = ''; // Clear existing cards
            for (let i = 0; i < 9; i++) { // Always render 9 slots for the 3x3 grid
                const card = availableCards[i];
                const cardElement = document.createElement('div');
                cardElement.classList.add('card', 'rounded-xl');
                cardElement.dataset.uniqueGridId = card.uniqueGridId; // Use uniqueGridId for selection

                // Add difficulty color class, but only if it's a real card (not an empty placeholder)
                if (card.originalIndex !== -1) { // Check for real card
                    cardElement.classList.add(`difficulty-${card.data.difficulty}-color`);
                }

                // Determine difficulty display HTML (Bonus: + coins)
                let difficultyDisplayHtml = '';
                if (card.originalIndex !== -1 && card.data.difficulty > 1) { // Only show bonus for difficulty > 1
                    difficultyDisplayHtml += 'Bonus: ';
                    for (let k = 0; k < (card.data.difficulty - 1); k++) { // 1 coin for difficulty 2, 2 coins for difficulty 3
                        difficultyDisplayHtml += getCoinSvgIcon();
                    }
                }

                if (card.answered || card.originalIndex === -1) { // If card is answered or is a placeholder
                    cardElement.classList.add('answered');
                    if (card.originalIndex === -1) { // It's a blank slot/exhausted question
                        cardElement.innerHTML = `
                            <div class="flex-grow flex items-center justify-center text-center p-2 text-sm md:text-base"></div>
                            <div class="difficulty-indicator"></div>
                        `; // Intentionally empty for blank slots
                    } else { // It's an answered card that will soon be shifted out
                        cardElement.innerHTML = `
                            <div class="flex-grow flex items-center justify-center text-center p-2 text-sm md:text-base">Zodpovƒõzeno</div>
                            <div class="difficulty-indicator">${difficultyDisplayHtml}</div>
                        `;
                    }
                    // Ensure tooltip listeners are removed for answered/placeholder cards
                    cardElement.removeEventListener('mouseover', handleCardMouseOver);
                    cardElement.removeEventListener('mousemove', handleCardMouseMove);
                    cardElement.removeEventListener('mouseout', handleCardMouseOut);
                } else { // If card is not answered (clickable)
                    const fullQuestion = card.data.question;
                    const questionSnippet = fullQuestion.substring(0, 50) + (fullQuestion.length > 50 ? '...' : '');
                    
                    cardElement.innerHTML = `
                        <div class="flex-grow flex items-center justify-center text-center p-2 text-sm md:text-base">${questionSnippet}</div>
                        <div class="difficulty-indicator">${difficultyDisplayHtml}</div>
                    `;
                    // Store full text on dataset for easy access for tooltip
                    cardElement.dataset.fullQuestion = fullQuestion; 

                    if (!isQuestionActive) {
                        cardElement.addEventListener('click', handleCardClick);
                        cardElement.style.cursor = 'pointer'; 

                        // Attach tooltip listeners only if text is truncated
                        if (fullQuestion.length > 50) { // Check if truncation actually occurred
                            cardElement.addEventListener('mouseover', handleCardMouseOver);
                            cardElement.addEventListener('mousemove', handleCardMouseMove);
                            cardElement.addEventListener('mouseout', handleCardMouseOut);
                        } else {
                            // Ensure listeners are removed if text is not truncated
                            cardElement.removeEventListener('mouseover', handleCardMouseOver);
                            cardElement.removeEventListener('mousemove', handleCardMouseMove);
                            cardElement.removeEventListener('mouseout', handleCardMouseOut);
                        }
                    } else {
                        cardElement.removeEventListener('click', handleCardClick);
                        cardElement.style.cursor = 'not-allowed';
                        // Always remove tooltip listeners if question is active (card not clickable)
                        cardElement.removeEventListener('mouseover', handleCardMouseOver);
                        cardElement.removeEventListener('mousemove', handleCardMouseMove);
                        cardElement.removeEventListener('mouseout', handleCardMouseOut);
                    }
                }
                if (cardGrid) cardGrid.appendChild(cardElement);
            }
        }

        // Generates HTML content for the question and options to be used in the modal
        function getQuestionModalContent(qData) {
            let options = [...qData.options, qData.answer];
            shuffleArray(options); // Randomize order of options

            let optionsHtml = options.map(option => `
                <button class="option-button rounded-lg" data-answer="${option}">
                    ${option}
                </button>
            `).join('');

            return `
                <div id="modal-question-area">
                    <p class="question-text">${qData.question}</p>
                    <div class="options-grid">
                        ${optionsHtml}
                    </div>
                    <div id="modal-feedback-message" class="feedback-message hidden"></div>
                </div>
            `;
        }

        // Handles click on a card in the grid
        function handleCardClick(event) {
            // Check if game should end before allowing card selection
            if (answeredCardsTotal >= TOTAL_CARDS_TO_ANSWER || usedFlashcardOriginalIndices.size === flashcardsData.length) {
                showGameModal(
                    "Konec hry",
                    "<p>Byly zodpovƒõzeny v≈°echny ot√°zky nebo vyƒçerp√°ny v≈°echny unik√°tn√≠ kartiƒçky.</p>",
                    "Zobrazit v√Ωsledky",
                    showEndGameSummary
                );
                return;
            }

            if (isQuestionActive) { // Prevent clicking another card while a question is active
                return;
            }

            const cardElement = event.currentTarget;
            const uniqueGridId = parseInt(cardElement.dataset.uniqueGridId);

            const card = availableCards.find(c => c.uniqueGridId === uniqueGridId);

            if (card.answered || card.originalIndex === -1) { // Prevent clicking already answered or empty slots
                return;
            }

            document.querySelectorAll('.card.selected').forEach(c => c.classList.remove('selected'));
            cardElement.classList.add('selected');

            currentQuestion = card;
            isQuestionActive = true;

            // Remove all click and tooltip listeners from all cards when a question is active
            if (cardGrid) { // Safety check for cardGrid
                Array.from(cardGrid.children).forEach(c => {
                    c.removeEventListener('click', handleCardClick);
                    c.style.cursor = 'not-allowed';
                    c.removeEventListener('mouseover', handleCardMouseOver);
                    c.removeEventListener('mousemove', handleCardMouseMove);
                    c.removeEventListener('mouseout', handleCardMouseOut);
                });
            }
            hideTooltip(); // Ensure tooltip is hidden if active when card is clicked

            const modalContent = getQuestionModalContent(card.data);
            
            showGameModal(
                "Ot√°zka",
                modalContent,
                null,
                null
            );

            const modalOptionsContainer = document.querySelector('#modal-question-area .options-grid');
            if (modalOptionsContainer) {
                Array.from(modalOptionsContainer.children).forEach(button => {
                    button.addEventListener('click', handleAnswerClickInModal);
                });
            }
        }

        // Handles click on an answer option within the modal
        function handleAnswerClickInModal(event) {
            const selectedOption = event.target.dataset.answer;
            const correctAnswer = currentQuestion.data.answer;
            const modalFeedbackMessage = document.getElementById('modal-feedback-message');
            const currentPlayer = players[currentPlayerIndex];

            let points = 0;
            let bonusPoints = 0;

            const cardElement = document.querySelector(`.card[data-unique-grid-id="${currentQuestion.uniqueGridId}"]`);
            const cardIndexInAvailableCards = currentQuestion.uniqueGridId; 
            const row = Math.floor(cardIndexInAvailableCards / 3) + 1;

            if (row === 2) {
                bonusPoints += 1;
            } else if (row === 3) {
                bonusPoints += 2;
            }

            if (currentQuestion.data.difficulty === 2) {
                bonusPoints += 1;
            } else if (currentQuestion.data.difficulty === 3) {
                bonusPoints += 2;
            }

            if (selectedOption === correctAnswer) {
                points = 1 + bonusPoints;
                currentPlayer.score += points;
                currentPlayer.correctAnswers++;
                modalFeedbackMessage.textContent = `Spr√°vnƒõ! Z√≠skali jste ${points} bod≈Ø.`;
                modalFeedbackMessage.classList.remove('text-red-600');
                modalFeedbackMessage.classList.add('text-green-600');
            } else {
                points = -(1 + bonusPoints);
                currentPlayer.score += points;
                currentPlayer.incorrectAnswers++;
                currentPlayer.incorrectAnswersHistory.push({
                    question: currentQuestion.data.question,
                    correctAnswer: correctAnswer,
                    userAnswer: selectedOption
                });
                modalFeedbackMessage.textContent = `≈†patnƒõ! Spr√°vn√° odpovƒõƒè byla: "${correctAnswer}". Ztratili jste ${Math.abs(points)} bod≈Ø.`;
                modalFeedbackMessage.classList.remove('text-green-600');
                modalFeedbackMessage.classList.add('text-red-600');
            }

            currentPlayer.score = Math.max(0, currentPlayer.score);
            // scoreDisplay.textContent = currentPlayer.score; // This is now handled by updateScoreDisplay()

            answeredCardsTotal++;
            window.updateScoreDisplay(); // Calling through window object

            if (modalFeedbackMessage) modalFeedbackMessage.classList.remove('hidden');

            const modalOptionsContainer = event.target.closest('.options-grid');
            if (modalOptionsContainer) { // Ensure container exists
                Array.from(modalOptionsContainer.children).forEach(button => {
                    button.removeEventListener('click', handleAnswerClickInModal);
                    if (button.dataset.answer === correctAnswer) {
                        button.classList.add('correct');
                    } else if (button.dataset.answer === selectedOption) {
                        button.classList.add('incorrect');
                    }
                    button.style.cursor = 'not-allowed';
                });
            }
            
            // Mark the card as answered in the availableCards array *immediately* for visual feedback
            const answeredCard = availableCards.find(card => card.uniqueGridId === currentQuestion.uniqueGridId);
            if (answeredCard) {
                answeredCard.answered = true;
                // Visually update the card to show "Zodpovƒõzeno"
                const answeredCardElement = document.querySelector(`.card[data-unique-grid-id="${currentQuestion.uniqueGridId}"]`);
                if (answeredCardElement) {
                    answeredCardElement.classList.add('answered');
                    answeredCardElement.classList.remove('selected');
                    // Remove all listeners from the answered card element
                    answeredCardElement.removeEventListener('click', handleCardClick); 
                    answeredCardElement.removeEventListener('mouseover', handleCardMouseOver);
                    answeredCardElement.removeEventListener('mousemove', handleCardMouseMove);
                    answeredCardElement.removeEventListener('mouseout', handleCardMouseOut);

                    // Re-render the difficulty indicator on answered card
                    let difficultyDisplayHtml = '';
                    if (answeredCard.originalIndex !== -1 && answeredCard.data.difficulty > 1) { 
                        difficultyDisplayHtml += 'Bonus: ';
                        for (let k = 0; k < (answeredCard.data.difficulty - 1); k++) { 
                            difficultyDisplayHtml += getCoinSvgIcon();
                        }
                    }

                    answeredCardElement.innerHTML = `
                        <div class="flex-grow flex items-center justify-center text-center p-2 text-sm md:text-base">Zodpovƒõzeno</div>
                        <div class="difficulty-indicator">${difficultyDisplayHtml}</div>
                    `;
                }
            }


            // Check for game end condition immediately after answering
            if (answeredCardsTotal >= TOTAL_CARDS_TO_ANSWER || usedFlashcardOriginalIndices.size === flashcardsData.length) {
                if (messageModalOverlay) messageModalOverlay.classList.remove('visible'); 
                showEndGameSummary();
            } else {
                if (modalPrimaryButton) {
                    modalPrimaryButton.classList.remove('hidden');
                    modalPrimaryButton.textContent = "Dal≈°√≠ tah";
                    modalPrimaryButton.onclick = () => {
                        if (messageModalOverlay) messageModalOverlay.classList.remove('visible');
                        nextPlayerTurn(); // This will trigger the actual shift/fill
                    };
                }

                // Add the new "Ukonƒçit a vyhodnotit" button
                if (modalSecondaryButton) {
                    modalSecondaryButton.classList.remove('hidden');
                    modalSecondaryButton.textContent = "Ukonƒçit a vyhodnotit";
                    modalSecondaryButton.onclick = () => {
                        if (messageModalOverlay) messageModalOverlay.classList.remove('visible');
                        showEndGameSummary();
                    };
                }
            }
        }

        /**
         * Switches to the next player and initiates the next round, handling the card shift.
         */
        function nextPlayerTurn() {
            // Reset isQuestionActive FIRST to ensure cards are clickable for the next turn
            isQuestionActive = false; 

            // Check if game should end before proceeding
            if (answeredCardsTotal >= TOTAL_CARDS_TO_ANSWER || usedFlashcardOriginalIndices.size === flashcardsData.length) {
                showEndGameSummary(); // End game if limits reached
                return;
            }

            const answeredCardGridId = currentQuestion.uniqueGridId; // Index of the card that was just answered

            // 1. Remove the answered card from its position in the array.
            availableCards.splice(answeredCardGridId, 1);

            // 2. Get a new card to add to the array (which will appear top-left).
            const newCardData = getNextAvailableFlashcardData();

            let newCardObject;
            if (answeredCardsTotal < TOTAL_CARDS_TO_ANSWER && newCardData) {
                newCardObject = {
                    uniqueGridId: -1, // Will be reassigned shortly
                    originalIndex: newCardData.originalIndex,
                    data: newCardData.data,
                    answered: false
                };
            } else {
                // If game limit reached or no more unique cards, add a placeholder
                newCardObject = {
                    uniqueGridId: -1, // Will be reassigned shortly
                    originalIndex: -1, // Indicates a blank/exhausted slot
                    data: { question: "", answer: "", options: [], difficulty: 0 },
                    answered: true // Treat as answered/unavailable (not clickable)
                };
            }

            // 3. Add the new card to the BEGINNING of the array using unshift.
            // This pushes all existing elements one position to the right (higher index).
            availableCards.unshift(newCardObject);

            // 4. Ensure the array size is exactly 9. Since we removed one and added one, it should be 9.
            // If the array ends up with more than 9 elements (e.g., due to an case or previous error),
            // remove the last one to maintain the 3x3 grid size.
            if (availableCards.length > 9) {
                 availableCards.pop(); // Remove the last element
            }


            // 5. Reassign uniqueGridIds for all 9 cards based on their new positions in the array.
            availableCards.forEach((card, index) => {
                card.uniqueGridId = index;
            });

            currentPlayerIndex = (currentPlayerIndex + 1) % numPlayers;
            window.updateScoreDisplay(); // Update display for new player and remaining cards
            renderCardGrid(); // Re-render the grid with shifted cards
            // isQuestionActive is already set to false at the beginning of this function.
        }

        /**
         * Returns the game to the setup screen, resetting inputs.
         */
        function returnToSetupScreen() {
            // First, get the currently selected URL, so we can re-select it after reset
            updateDomElementReferences(); // Ensure flashcardSetSelect is available
            const selectedUrlBeforeReset = flashcardSetSelect ? flashcardSetSelect.value : currentFlashcardSetUrl;

            resetGameParametersAndState();
            // Load flashcards for the currently selected set AFTER reset
            // This will also ensure the dropdown visually matches currentFlashcardSetUrl
            loadFlashcards(selectedUrlBeforeReset);
        }

        // Displays the end game summary modal
        function showEndGameSummary() {
            isQuestionActive = true; 

            let summaryContent = `
                <p class="mb-4 text-xl font-bold">Hra skonƒçila!</p>
                <div class="text-left mb-4">
                    <h4 class="font-semibold text-lg mb-2">V√Ωsledky hr√°ƒç≈Ø:</h4>
                    ${players.map(player => `
                        <p><span class="font-semibold" style="color: ${player.color};">${player.emoji} ${player.name}</span>: <strong class="text-blue-700">${player.score}</strong> bod≈Ø (Spr√°vnƒõ: ${player.correctAnswers}, ≈†patnƒõ: ${player.incorrectAnswers})</p>
                    `).join('')}
                </div>
            `;

            // Add buttons for each player to view their incorrect answers
            let playerDetailsButtons = players.map((player, index) => `
                <button class="modal-button secondary mt-2 mr-2" onclick="window.showPlayerIncorrectAnswers(${index})">
                    Chybn√© odpovƒõdi ${player.name}
                </button>
            `).join('');

            showGameModal(
                "Hra dokonƒçena!",
                summaryContent + `<div class="modal-buttons-container flex-col">${playerDetailsButtons}</div>`,
                "Hr√°t znovu",
                returnToSetupScreen // Changed to return to setup screen
            );

            // Hide all game play elements
            if (questionArea) questionArea.classList.add('hidden');
            if (cardGrid) cardGrid.innerHTML = ''; // Clear grid
        }

        /**
         * Displays the incorrect answers modal for a specific player.
         * @param {number} playerIndex - The index of the player whose incorrect answers to show.
         */
        // Explicitly defining on window object to ensure global accessibility
        window.showPlayerIncorrectAnswers = function(playerIndex) { 
            const player = players[playerIndex];
            let incorrectListHTML = '';
            if (player.incorrectAnswersHistory.length > 0) {
                incorrectListHTML = '<ul>' + player.incorrectAnswersHistory.map(item => `
                    <li>
                        <div class="question-text-small">Ot√°zka: ${item.question}</div>
                        <div class="answer-text-small">Spr√°vn√° odpovƒõƒè: ${item.correctAnswer}</div>
                        <div class="user-answer-text-small">Va≈°e odpovƒõƒè: ${item.userAnswer}</div>
                    </li>
                `).join('') + '</ul>';
            } else {
                incorrectListHTML = '<p>Nem√°te ≈æ√°dn√© ≈°patn√© odpovƒõdi! Gratulujeme!</p>';
            }

            showGameModal(
                `≈†patn√© odpovƒõdi - ${player.name}`,
                incorrectListHTML,
                "Hr√°t znovu",
                returnToSetupScreen, // Changed to return to setup screen
                "Zpƒõt na souhrn",
                showEndGameSummary // Go back to summary
            );
        }

        /**
         * Loads flashcards data from the specified Google Sheet TSV URL.
         * @param {string} [urlToLoad=currentFlashcardSetUrl] - The URL of the Google Sheet to load.
         */
        async function loadFlashcards(urlToLoad = currentFlashcardSetUrl) {
            // Get initial setup screen reference
            updateDomElementReferences(); // Ensure gameSetupScreen is up-to-date

            // Show loading indicator
            if (gameSetupScreen) {
                gameSetupScreen.innerHTML = `
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">Naƒç√≠t√°n√≠ kartiƒçek...</h2>
                    <p class="text-md text-gray-600">Pros√≠m ƒçekejte, naƒç√≠t√°me ot√°zky z datab√°ze.</p>
                `;
            }
            

            try {
                const response = await fetch(urlToLoad);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const tsvData = await response.text();
                console.log("Raw TSV data:", tsvData); // Log raw data for debugging

                const lines = tsvData.split('\n').filter(line => line.trim() !== '');
                console.log("TSV lines:", lines); // Log split lines

                if (lines.length <= 1) {
                    throw new Error('No flashcard data found in the spreadsheet or invalid format.');
                }

                // Make headers case-insensitive and trim spaces for more robust matching
                const headers = lines[0].split('\t').map(h => h.trim().toLowerCase());
                console.log("Parsed Headers:", headers); // Log parsed headers

                const dataRows = lines.slice(1);

                flashcardsData = dataRows.map(row => {
                    const values = row.split('\t').map(v => v.trim());
                    const card = {};
                    
                    // Map headers to card properties
                    headers.forEach((header, index) => {
                        const value = values[index];
                        if (header === "question") { // Case-insensitive header match
                            card.question = value;
                        } else if (header === "correct answer") { // Case-insensitive header match
                            card.answer = value;
                        } else if (header.startsWith("option")) { // Case-insensitive header match for options
                            if (!card.options) card.options = [];
                            if (value) card.options.push(value);
                        } else if (header === "difficulty") { // Case-insensitive header match
                            card.difficulty = parseInt(value) || 1; // Default to 1 if parsing fails
                        }
                    });
                    
                    // Ensure options array exists even if no options were found (e.g., only correct answer)
                    if (!card.options) card.options = [];

                    // Filter out cards that don't have a question or answer
                    if (!card.question || !card.answer) {
                        console.warn("Skipping malformed flashcard row (missing question or answer):", row, "Parsed card:", card);
                        return null;
                    }
                    console.log("Parsed Card:", card); // Log each parsed card
                    return card;
                }).filter(card => card !== null); // Filter out nulls from malformed cards

                if (flashcardsData.length === 0) {
                    throw new Error('Parsed flashcard data is empty. Check spreadsheet format. (No valid cards found)');
                }
                console.log("Final flashcardsData:", flashcardsData); // Log the final data array

                // Restore initial setup screen content and re-enable button
                if (gameSetupScreen) {
                    gameSetupScreen.innerHTML = `
                        <h2 class="text-2xl font-bold text-gray-800 mb-4">Nastaven√≠ hry</h2>
                        <div class="mb-4">
                            <label for="num-players" class="block text-gray-700 text-sm font-bold mb-2">Poƒçet hr√°ƒç≈Ø: <span id="num-players-value">1</span></label>
                            <input type="range" id="num-players" value="1" min="1" max="5" 
                                class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                        </div>
                        <div class="mb-6">
                            <label for="total-cards-input" class="block text-gray-700 text-sm font-bold mb-2">Celkem ot√°zek: <span id="total-cards-value">15</span></label>
                            <input type="range" id="total-cards-input" value="15" min="1"
                                class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                        </div>
                        <div class="mb-6">
                            <label for="flashcard-set-select" class="block text-gray-700 text-sm font-bold mb-2">Vybrat sadu kartiƒçek:</label>
                            <select id="flashcard-set-select" class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <!-- Options will be populated by JS -->
                            </select>
                        </div>
                        <p class="text-md text-gray-600 mb-8" id="game-instructions">Z√°kladn√≠ bodov√°n√≠: +1 za spr√°vnou, -1 za ≈°patnou. Bonusy za ≈ô√°dek a obt√≠≈ænost se p≈ôiƒç√≠taj√≠/odeƒç√≠taj√≠ k tomu.</p>
                        <button id="setup-game-button" class="start-button">Zaƒç√≠t hru</button>
                    `;
                }
                
                // Re-attach event listeners after innerHTML replacement, as they are lost
                updateDomElementReferences(); // Re-fetch all references after innerHTML update

                // Populate flashcard set select options
                if (flashcardSetSelect) {
                    // Clear existing options first to prevent duplicates
                    flashcardSetSelect.innerHTML = ''; 
                    for (const key in FLASHCARD_SETS) {
                        const option = document.createElement('option');
                        option.value = FLASHCARD_SETS[key].url; // Store URL as value
                        option.textContent = FLASHCARD_SETS[key].name;
                        flashcardSetSelect.appendChild(option);
                    }
                    // Set the selected value to the one that was just loaded
                    flashcardSetSelect.value = urlToLoad;
                }

                if (setupGameButton) setupGameButton.addEventListener('click', setupGame);
                if (numPlayersInput) numPlayersInput.addEventListener('input', (event) => { // Changed from 'change' to 'input' for live update
                    if (numPlayersValueSpan) numPlayersValueSpan.textContent = event.target.value;
                    updateDefaultTotalCards(); // Call to update total cards based on new player count
                });
                if (totalCardsInput) totalCardsInput.addEventListener('input', (event) => {
                    if (totalCardsValueSpan) totalCardsValueSpan.textContent = event.target.value;
                });
                // Add event listener for flashcard set change
                if (flashcardSetSelect) {
                    flashcardSetSelect.removeEventListener('change', handleFlashcardSetChange); // Prevent duplicate listeners
                    flashcardSetSelect.addEventListener('change', handleFlashcardSetChange);
                }

                if (setupGameButton) setupGameButton.disabled = false; // Re-enable the button
                updateDefaultTotalCards(); // Call this once to initialize the slider value and max
                console.log("Flashcards loaded successfully and setup screen initialized.");

            } catch (error) {
                console.error('Failed to load flashcards:', error);
                // Find the name of the set that failed to load
                let failedSetName = "Nezn√°m√° sada";
                for (const key in FLASHCARD_SETS) {
                    if (FLASHCARD_SETS[key].url === urlToLoad) {
                        failedSetName = FLASHCARD_SETS[key].name;
                        break;
                    }
                }

                const errorMessageHTML = `
                    <p class="text-md text-gray-800 mb-4">Nepoda≈ôilo se naƒç√≠st sadu kartiƒçek:</p>
                    <p class="text-lg font-bold text-red-600 mb-4">"${failedSetName}"</p>
                    <p class="text-sm text-gray-600 mb-4">Pros√≠m, zkontrolujte:</p>
                    <ul class="text-sm text-gray-600 text-left list-disc list-inside mb-4">
                        <li>Zda je adresa URL spr√°vn√°: <a href="${urlToLoad}" target="_blank" class="text-blue-500 underline">odkaz na tabulku</a>.</li>
                        <li>Zda je Google tabulka sd√≠lena jako "Publikovat na webu" ve form√°tu TSV.</li>
                        <li>Zda m√° tabulka spr√°vn√© z√°hlav√≠ sloupc≈Ø (ignoruj√≠ se mezery a velikost p√≠smen): <strong>"Question", "Correct Answer", "Option 1", "Option 2", "Difficulty"</strong>.</li>
                        <li>Zda nejsou sloupce "Question" nebo "Correct Answer" pr√°zdn√© pro v≈°echny ≈ô√°dky s ot√°zkami.</li>
                    </ul>
                    <p class="text-sm text-gray-600">Detaily chyby: ${error.message}</p>
                `;

                showGameModal(
                    "Chyba p≈ôi naƒç√≠t√°n√≠ kartiƒçek!",
                    errorMessageHTML,
                    "Zkusit znovu",
                    () => {
                        // Attempt to load the *previous* or default set, not the one that just failed
                        // To avoid infinite loop if the selected URL is consistently bad
                        const defaultSetKey = Object.keys(FLASHCARD_SETS)[0];
                        currentFlashcardSetUrl = FLASHCARD_SETS[defaultSetKey].url; // Revert to default
                        resetGameParametersAndState(); 
                        loadFlashcards(currentFlashcardSetUrl); 
                    }
                );
                // If a button exists from a previous render, try to disable it.
                if (setupGameButton) setupGameButton.disabled = true; 
            }
        }

        // New handler for flashcard set change
        function handleFlashcardSetChange(event) {
            currentFlashcardSetUrl = event.target.value;
            resetGameParametersAndState(); // Reset game state and parameters (but not currentFlashcardSetUrl)
            loadFlashcards(currentFlashcardSetUrl); // Load new flashcards
        }

        // Call loadFlashcards on window load to start fetching data immediately
        window.onload = async () => {
            // Initial call to ensure all DOM element references are set up.
            updateDomElementReferences(); 

            // Set up initial options for the dropdown and select the default one
            if (flashcardSetSelect) {
                for (const key in FLASHCARD_SETS) {
                    const option = document.createElement('option');
                    option.value = FLASHCARD_SETS[key].url;
                    option.textContent = FLASHCARD_SETS[key].name;
                    flashcardSetSelect.appendChild(option);
                }
                flashcardSetSelect.value = currentFlashcardSetUrl; // Set default selection
            }

            // Attach event listeners for setup screen elements
            if (setupGameButton) setupGameButton.addEventListener('click', setupGame);
            if (numPlayersInput) numPlayersInput.addEventListener('input', (event) => {
                if (numPlayersValueSpan) numPlayersValueSpan.textContent = event.target.value;
                updateDefaultTotalCards();
            });
            if (totalCardsInput) totalCardsInput.addEventListener('input', (event) => {
                if (totalCardsValueSpan) totalCardsValueSpan.textContent = event.target.value;
            });
            if (flashcardSetSelect) {
                flashcardSetSelect.addEventListener('change', handleFlashcardSetChange);
            }

            // Now load the initial set
            await loadFlashcards(currentFlashcardSetUrl); 
        };
    </script>
</body>
</html>
